---

name: Свойства и методы
theory: |

  В своих программах мы оперируем различными данными (числами, строками, функциями). Эти данные являются объектами и обладают атрибутами, в которых могут храниться свойства. Например, у комплексных чисел есть свойства, хранящие реальную и мнимую часть числа. В Python атрибуты встроены прямо в язык. Они указываются через точку сразу после переменной:

  ```python
  num = (1+3j)
  print(num.imag)  # => 3.0
  print(num.real)  # => 1.0
  ```

  Python не позволяет обращаться к свойствам, которые не существуют. Вы получите ошибку `AttributeError`:

  ```python
  num = 1
  print(num.what_is_that)
  # Traceback (most recent call last):
  #   File "<stdin>", line 1, in <module>
  # AttributeError: 'int' object has no attribute 'what_is_that'
  ```

  Кроме свойств, у данных существуют методы — функции, находящиеся внутри атрибутов. С практической точки зрения это значит, что метод работает и вызывается как функция, но делает это как свойство, через точку:

  ```python
  name = 'Robb'
  upper_name = name.upper()
  print(upper_name)  # => 'ROBB'
  ```

  Встроенные методы всегда оперируют теми данными, с которыми они связаны. Метод `.upper()` возвращает ту же строку, но преобразуя все символы в верхний регистр. Методов у данных достаточно много, например, для строк их [несколько десятков](https://docs.python.org/3/library/stdtypes.html#string-methods).

  Методы есть и у [чисел](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types):

  ```python
  num = 5
  # Вычисляем количество бит,
  # необходимых для представления числа в двоичном виде
  bits_count = num.bit_length()
  # Метод возвращает строку, которая содержит преобразованное число
  print(bits_count)  # => 3

  # Напрямую можно вызывать так
  # Скобки нужны обязательно, иначе не заработает
  (5).bit_length()  # 3
  ```

  _Хозяйке на заметку. Технически всё несколько сложнее. Методы есть не у самих чисел, а у данных (объектов) определённого типа (int, float, complex). Числа, записанные в переменные, автоматически преобразуются к данному типу во время обращения к ним, в это время происходит так называемый boxing._

  Возникает закономерный вопрос: зачем нужны методы, почему не просто функции? Дело в том, что далеко не все функции имеют отношение к конкретному значению. Возьмем для примера `min()`. Эта функция находит минимальное число среди всех, которые ему были переданы. Эту функцию нелогично делать методом конкретного числа, например, так — `(1).min()`. Она не имеет никакой связи с конкретным числом.

  С другой стороны, функции, работающие с конкретным числом, для единообразия должны быть реализованы как методы. К таким функциям относится получение модуля числа. В итоге мы имеем вызов `abs(-10)`, аналогичный вызову метода `(-10).__abs__()`.

  Что касается методов в целом, то не все так однозначно. Есть языки, в которых методов нет и там всё прекрасно. Есть языки, где методы — это основной способ работы с функциями, но даже в этих языках всегда, наряду с методами, используются обычные функции. Python — язык, в котором используются оба подхода, в нём активно используются как обычные функции, так и методы. О плюсах и минусах подобных подходов рассказывается в курсах [посвященных ООП](https://ru.hexlet.io/courses/python-oop-basics).

instructions: |
  Приведите строку `text` к нижнему регистру и напечатайте её на экран.

tips:
  - |
    [Метод строки lower()](https://docs.python.org/3/library/stdtypes.html?highlight=lower#str.lower)
